{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Freqenz Client Base Library","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Utilities for writing Frequenz API clients</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Freqenz Client Base Library","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>client<ul> <li>base<ul> <li>grpc_streaming_helper</li> <li>retry_strategy</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/client/base/","title":"Index","text":""},{"location":"reference/frequenz/client/base/#frequenz.client.base","title":"frequenz.client.base","text":"<p>Utilities for writing Frequenz API clients.</p>"},{"location":"reference/frequenz/client/base/grpc_streaming_helper/","title":"grpc_streaming_helper","text":""},{"location":"reference/frequenz/client/base/grpc_streaming_helper/#frequenz.client.base.grpc_streaming_helper","title":"frequenz.client.base.grpc_streaming_helper","text":"<p>Implementation of the grpc streaming helper.</p>"},{"location":"reference/frequenz/client/base/grpc_streaming_helper/#frequenz.client.base.grpc_streaming_helper-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/base/grpc_streaming_helper/#frequenz.client.base.grpc_streaming_helper.GrpcStreamingHelper","title":"frequenz.client.base.grpc_streaming_helper.GrpcStreamingHelper","text":"<p>             Bases: <code>Generic[_InputT, _OutputT]</code></p> <p>Helper class to handle grpc streaming methods.</p> Source code in <code>frequenz/client/base/grpc_streaming_helper.py</code> <pre><code>class GrpcStreamingHelper(typing.Generic[_InputT, _OutputT]):\n\"\"\"Helper class to handle grpc streaming methods.\"\"\"\ndef __init__(\nself,\nstream_name: str,\nstream_method: typing.Callable[[], UnaryStreamCall[typing.Any, _InputT]],\ntransform: typing.Callable[[_InputT], _OutputT],\nretry_spec: retry_strategy.RetryStrategy | None = None,\n):\n\"\"\"Initialize the streaming helper.\n        Args:\n            stream_name: A name to identify the stream in the logs.\n            stream_method: A function that returns the grpc stream. This function is\n                called everytime the connection is lost and we want to retry.\n            transform: A function to transform the input type to the output type.\n            retry_spec: The retry strategy to use, when the connection is lost. Defaults\n                to retries every 3 seconds, with a jitter of 1 second, indefinitely.\n        \"\"\"\nself._stream_name = stream_name\nself._stream_method = stream_method\nself._transform = transform\nself._retry_spec = (\nretry_strategy.LinearBackoff() if retry_spec is None else retry_spec.copy()\n)\nself._channel: channels.Broadcast[_OutputT] = channels.Broadcast(\nf\"GrpcStreamingHelper-{stream_name}\"\n)\nself._task = asyncio.create_task(self._run())\ndef new_receiver(self, maxsize: int = 50) -&gt; channels.Receiver[_OutputT]:\n\"\"\"Create a new receiver for the stream.\n        Args:\n            maxsize: The maximum number of messages to buffer.\n        Returns:\n            A new receiver.\n        \"\"\"\nreturn self._channel.new_receiver(maxsize=maxsize)\nasync def stop(self) -&gt; None:\n\"\"\"Stop the streaming helper.\"\"\"\nif self._task.done():\nreturn\nself._task.cancel()\ntry:\nawait self._task\nexcept asyncio.CancelledError:\npass\nawait self._channel.close()\nasync def _run(self) -&gt; None:\n\"\"\"Run the streaming helper.\"\"\"\nsender = self._channel.new_sender()\nwhile True:\n_logger.debug(\"Making call to grpc streaming method: %s\", self._stream_name)\ntry:\ncall = self._stream_method()\nasync for msg in call:\nawait sender.send(self._transform(msg))\nexcept grpc.aio.AioRpcError:\n_logger.exception(\n\"Error in grpc streaming method: %s\", self._stream_name\n)\nif interval := self._retry_spec.next_interval():\n_logger.warning(\n\"`%s`, connection ended, retrying %s in %0.3f seconds.\",\nself._stream_name,\nself._retry_spec.get_progress(),\ninterval,\n)\nawait asyncio.sleep(interval)\nelse:\n_logger.warning(\n\"`%s`, connection ended, retry limit exceeded %s.\",\nself._stream_name,\nself._retry_spec.get_progress(),\n)\nawait self._channel.close()\nbreak\n</code></pre>"},{"location":"reference/frequenz/client/base/grpc_streaming_helper/#frequenz.client.base.grpc_streaming_helper.GrpcStreamingHelper-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/grpc_streaming_helper/#frequenz.client.base.grpc_streaming_helper.GrpcStreamingHelper.__init__","title":"__init__","text":"<pre><code>__init__(\nstream_name: str,\nstream_method: typing.Callable[\n[], UnaryStreamCall[typing.Any, _InputT]\n],\ntransform: typing.Callable[[_InputT], _OutputT],\nretry_spec: retry_strategy.RetryStrategy | None = None,\n)\n</code></pre> <p>Initialize the streaming helper.</p> PARAMETER  DESCRIPTION <code>stream_name</code> <p>A name to identify the stream in the logs.</p> <p> TYPE: <code>str</code> </p> <code>stream_method</code> <p>A function that returns the grpc stream. This function is called everytime the connection is lost and we want to retry.</p> <p> TYPE: <code>Callable[[], UnaryStreamCall[Any, _InputT]]</code> </p> <code>transform</code> <p>A function to transform the input type to the output type.</p> <p> TYPE: <code>Callable[[_InputT], _OutputT]</code> </p> <code>retry_spec</code> <p>The retry strategy to use, when the connection is lost. Defaults to retries every 3 seconds, with a jitter of 1 second, indefinitely.</p> <p> TYPE: <code>RetryStrategy | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/client/base/grpc_streaming_helper.py</code> <pre><code>def __init__(\nself,\nstream_name: str,\nstream_method: typing.Callable[[], UnaryStreamCall[typing.Any, _InputT]],\ntransform: typing.Callable[[_InputT], _OutputT],\nretry_spec: retry_strategy.RetryStrategy | None = None,\n):\n\"\"\"Initialize the streaming helper.\n    Args:\n        stream_name: A name to identify the stream in the logs.\n        stream_method: A function that returns the grpc stream. This function is\n            called everytime the connection is lost and we want to retry.\n        transform: A function to transform the input type to the output type.\n        retry_spec: The retry strategy to use, when the connection is lost. Defaults\n            to retries every 3 seconds, with a jitter of 1 second, indefinitely.\n    \"\"\"\nself._stream_name = stream_name\nself._stream_method = stream_method\nself._transform = transform\nself._retry_spec = (\nretry_strategy.LinearBackoff() if retry_spec is None else retry_spec.copy()\n)\nself._channel: channels.Broadcast[_OutputT] = channels.Broadcast(\nf\"GrpcStreamingHelper-{stream_name}\"\n)\nself._task = asyncio.create_task(self._run())\n</code></pre>"},{"location":"reference/frequenz/client/base/grpc_streaming_helper/#frequenz.client.base.grpc_streaming_helper.GrpcStreamingHelper.new_receiver","title":"new_receiver","text":"<pre><code>new_receiver(\nmaxsize: int = 50,\n) -&gt; channels.Receiver[_OutputT]\n</code></pre> <p>Create a new receiver for the stream.</p> PARAMETER  DESCRIPTION <code>maxsize</code> <p>The maximum number of messages to buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Receiver[_OutputT]</code> <p>A new receiver.</p> Source code in <code>frequenz/client/base/grpc_streaming_helper.py</code> <pre><code>def new_receiver(self, maxsize: int = 50) -&gt; channels.Receiver[_OutputT]:\n\"\"\"Create a new receiver for the stream.\n    Args:\n        maxsize: The maximum number of messages to buffer.\n    Returns:\n        A new receiver.\n    \"\"\"\nreturn self._channel.new_receiver(maxsize=maxsize)\n</code></pre>"},{"location":"reference/frequenz/client/base/grpc_streaming_helper/#frequenz.client.base.grpc_streaming_helper.GrpcStreamingHelper.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the streaming helper.</p> Source code in <code>frequenz/client/base/grpc_streaming_helper.py</code> <pre><code>async def stop(self) -&gt; None:\n\"\"\"Stop the streaming helper.\"\"\"\nif self._task.done():\nreturn\nself._task.cancel()\ntry:\nawait self._task\nexcept asyncio.CancelledError:\npass\nawait self._channel.close()\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/","title":"retry_strategy","text":""},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy","title":"frequenz.client.base.retry_strategy","text":"<p>Implementations for retry strategies.</p>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.ExponentialBackoff","title":"frequenz.client.base.retry_strategy.ExponentialBackoff","text":"<p>             Bases: <code>RetryStrategy</code></p> <p>Provides methods for calculating the exponential interval between retries.</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>class ExponentialBackoff(RetryStrategy):\n\"\"\"Provides methods for calculating the exponential interval between retries.\"\"\"\nDEFAULT_INTERVAL = _DEFAULT_RETRY_INTERVAL\n\"\"\"Default retry interval, in seconds.\"\"\"\nDEFAULT_MAX_INTERVAL = 60.0\n\"\"\"Default maximum retry interval, in seconds.\"\"\"\nDEFAULT_MULTIPLIER = 2.0\n\"\"\"Default multiplier for exponential increment.\"\"\"\n# pylint: disable=too-many-arguments\ndef __init__(\nself,\ninitial_interval: float = DEFAULT_INTERVAL,\nmax_interval: float = DEFAULT_MAX_INTERVAL,\nmultiplier: float = DEFAULT_MULTIPLIER,\njitter: float = _DEFAULT_RETRY_JITTER,\nlimit: int | None = None,\n) -&gt; None:\n\"\"\"Create a `ExponentialBackoff` instance.\n        Args:\n            initial_interval: time to wait for before the first retry, in\n                seconds.\n            max_interval: maximum interval, in seconds.\n            multiplier: exponential increment for interval.\n            jitter: a jitter to add to the retry interval.\n            limit: max number of retries before giving up.  `None` means no\n                limit, and `0` means no retry.\n        \"\"\"\nself._initial = initial_interval\nself._max = max_interval\nself._multiplier = multiplier\nself._jitter = jitter\nself._limit = limit\nself._count = 0\ndef next_interval(self) -&gt; float | None:\n\"\"\"Return the time to wait before the next retry.\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\nif self._limit is not None and self._count &gt;= self._limit:\nreturn None\nself._count += 1\nexp_backoff_interval = self._initial * self._multiplier ** (self._count - 1)\nreturn min(exp_backoff_interval + random.uniform(0.0, self._jitter), self._max)\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.ExponentialBackoff-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.ExponentialBackoff.DEFAULT_INTERVAL","title":"DEFAULT_INTERVAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_INTERVAL = _DEFAULT_RETRY_INTERVAL\n</code></pre> <p>Default retry interval, in seconds.</p>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.ExponentialBackoff.DEFAULT_MAX_INTERVAL","title":"DEFAULT_MAX_INTERVAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_MAX_INTERVAL = 60.0\n</code></pre> <p>Default maximum retry interval, in seconds.</p>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.ExponentialBackoff.DEFAULT_MULTIPLIER","title":"DEFAULT_MULTIPLIER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEFAULT_MULTIPLIER = 2.0\n</code></pre> <p>Default multiplier for exponential increment.</p>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.ExponentialBackoff-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.ExponentialBackoff.__init__","title":"__init__","text":"<pre><code>__init__(\ninitial_interval: float = DEFAULT_INTERVAL,\nmax_interval: float = DEFAULT_MAX_INTERVAL,\nmultiplier: float = DEFAULT_MULTIPLIER,\njitter: float = _DEFAULT_RETRY_JITTER,\nlimit: int | None = None,\n) -&gt; None\n</code></pre> <p>Create a <code>ExponentialBackoff</code> instance.</p> PARAMETER  DESCRIPTION <code>initial_interval</code> <p>time to wait for before the first retry, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_INTERVAL</code> </p> <code>max_interval</code> <p>maximum interval, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_MAX_INTERVAL</code> </p> <code>multiplier</code> <p>exponential increment for interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_MULTIPLIER</code> </p> <code>jitter</code> <p>a jitter to add to the retry interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>_DEFAULT_RETRY_JITTER</code> </p> <code>limit</code> <p>max number of retries before giving up.  <code>None</code> means no limit, and <code>0</code> means no retry.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>def __init__(\nself,\ninitial_interval: float = DEFAULT_INTERVAL,\nmax_interval: float = DEFAULT_MAX_INTERVAL,\nmultiplier: float = DEFAULT_MULTIPLIER,\njitter: float = _DEFAULT_RETRY_JITTER,\nlimit: int | None = None,\n) -&gt; None:\n\"\"\"Create a `ExponentialBackoff` instance.\n    Args:\n        initial_interval: time to wait for before the first retry, in\n            seconds.\n        max_interval: maximum interval, in seconds.\n        multiplier: exponential increment for interval.\n        jitter: a jitter to add to the retry interval.\n        limit: max number of retries before giving up.  `None` means no\n            limit, and `0` means no retry.\n    \"\"\"\nself._initial = initial_interval\nself._max = max_interval\nself._multiplier = multiplier\nself._jitter = jitter\nself._limit = limit\nself._count = 0\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.ExponentialBackoff.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[float]\n</code></pre> <p>Return an iterator over the retry intervals.</p> YIELDS DESCRIPTION <code>float</code> <p>Next retry interval in seconds.</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float]:\n\"\"\"Return an iterator over the retry intervals.\n    Yields:\n        Next retry interval in seconds.\n    \"\"\"\nwhile True:\ninterval = self.next_interval()\nif interval is None:\nbreak\nyield interval\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.ExponentialBackoff.copy","title":"copy","text":"<pre><code>copy() -&gt; RetryStrategy\n</code></pre> <p>Create a new instance of <code>self</code>.</p> RETURNS DESCRIPTION <code>RetryStrategy</code> <p>A deepcopy of <code>self</code>.</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>def copy(self) -&gt; RetryStrategy:\n\"\"\"Create a new instance of `self`.\n    Returns:\n        A deepcopy of `self`.\n    \"\"\"\nret = deepcopy(self)\nret.reset()\nreturn ret\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.ExponentialBackoff.get_progress","title":"get_progress","text":"<pre><code>get_progress() -&gt; str\n</code></pre> <p>Return a string denoting the retry progress.</p> RETURNS DESCRIPTION <code>str</code> <p>String denoting retry progress in the form \"(count/limit)\"</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>def get_progress(self) -&gt; str:\n\"\"\"Return a string denoting the retry progress.\n    Returns:\n        String denoting retry progress in the form \"(count/limit)\"\n    \"\"\"\nif self._limit is None:\nreturn f\"({self._count}/\u221e)\"\nreturn f\"({self._count}/{self._limit})\"\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.ExponentialBackoff.next_interval","title":"next_interval","text":"<pre><code>next_interval() -&gt; float | None\n</code></pre> <p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>float | None</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>def next_interval(self) -&gt; float | None:\n\"\"\"Return the time to wait before the next retry.\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\nif self._limit is not None and self._count &gt;= self._limit:\nreturn None\nself._count += 1\nexp_backoff_interval = self._initial * self._multiplier ** (self._count - 1)\nreturn min(exp_backoff_interval + random.uniform(0.0, self._jitter), self._max)\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.ExponentialBackoff.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the retry counter.</p> <p>To be called as soon as a connection is successful.</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>def reset(self) -&gt; None:\n\"\"\"Reset the retry counter.\n    To be called as soon as a connection is successful.\n    \"\"\"\nself._count = 0\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.LinearBackoff","title":"frequenz.client.base.retry_strategy.LinearBackoff","text":"<p>             Bases: <code>RetryStrategy</code></p> <p>Provides methods for calculating the interval between retries.</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>class LinearBackoff(RetryStrategy):\n\"\"\"Provides methods for calculating the interval between retries.\"\"\"\ndef __init__(\nself,\ninterval: float = _DEFAULT_RETRY_INTERVAL,\njitter: float = _DEFAULT_RETRY_JITTER,\nlimit: int | None = None,\n) -&gt; None:\n\"\"\"Create a `LinearBackoff` instance.\n        Args:\n            interval: time to wait for before the next retry, in seconds.\n            jitter: a jitter to add to the retry interval.\n            limit: max number of retries before giving up.  `None` means no\n                limit, and `0` means no retry.\n        \"\"\"\nself._interval = interval\nself._jitter = jitter\nself._limit = limit\nself._count = 0\ndef next_interval(self) -&gt; float | None:\n\"\"\"Return the time to wait before the next retry.\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\nif self._limit is not None and self._count &gt;= self._limit:\nreturn None\nself._count += 1\nreturn self._interval + random.uniform(0.0, self._jitter)\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.LinearBackoff-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.LinearBackoff.__init__","title":"__init__","text":"<pre><code>__init__(\ninterval: float = _DEFAULT_RETRY_INTERVAL,\njitter: float = _DEFAULT_RETRY_JITTER,\nlimit: int | None = None,\n) -&gt; None\n</code></pre> <p>Create a <code>LinearBackoff</code> instance.</p> PARAMETER  DESCRIPTION <code>interval</code> <p>time to wait for before the next retry, in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>_DEFAULT_RETRY_INTERVAL</code> </p> <code>jitter</code> <p>a jitter to add to the retry interval.</p> <p> TYPE: <code>float</code> DEFAULT: <code>_DEFAULT_RETRY_JITTER</code> </p> <code>limit</code> <p>max number of retries before giving up.  <code>None</code> means no limit, and <code>0</code> means no retry.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>def __init__(\nself,\ninterval: float = _DEFAULT_RETRY_INTERVAL,\njitter: float = _DEFAULT_RETRY_JITTER,\nlimit: int | None = None,\n) -&gt; None:\n\"\"\"Create a `LinearBackoff` instance.\n    Args:\n        interval: time to wait for before the next retry, in seconds.\n        jitter: a jitter to add to the retry interval.\n        limit: max number of retries before giving up.  `None` means no\n            limit, and `0` means no retry.\n    \"\"\"\nself._interval = interval\nself._jitter = jitter\nself._limit = limit\nself._count = 0\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.LinearBackoff.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[float]\n</code></pre> <p>Return an iterator over the retry intervals.</p> YIELDS DESCRIPTION <code>float</code> <p>Next retry interval in seconds.</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float]:\n\"\"\"Return an iterator over the retry intervals.\n    Yields:\n        Next retry interval in seconds.\n    \"\"\"\nwhile True:\ninterval = self.next_interval()\nif interval is None:\nbreak\nyield interval\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.LinearBackoff.copy","title":"copy","text":"<pre><code>copy() -&gt; RetryStrategy\n</code></pre> <p>Create a new instance of <code>self</code>.</p> RETURNS DESCRIPTION <code>RetryStrategy</code> <p>A deepcopy of <code>self</code>.</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>def copy(self) -&gt; RetryStrategy:\n\"\"\"Create a new instance of `self`.\n    Returns:\n        A deepcopy of `self`.\n    \"\"\"\nret = deepcopy(self)\nret.reset()\nreturn ret\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.LinearBackoff.get_progress","title":"get_progress","text":"<pre><code>get_progress() -&gt; str\n</code></pre> <p>Return a string denoting the retry progress.</p> RETURNS DESCRIPTION <code>str</code> <p>String denoting retry progress in the form \"(count/limit)\"</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>def get_progress(self) -&gt; str:\n\"\"\"Return a string denoting the retry progress.\n    Returns:\n        String denoting retry progress in the form \"(count/limit)\"\n    \"\"\"\nif self._limit is None:\nreturn f\"({self._count}/\u221e)\"\nreturn f\"({self._count}/{self._limit})\"\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.LinearBackoff.next_interval","title":"next_interval","text":"<pre><code>next_interval() -&gt; float | None\n</code></pre> <p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>float | None</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>def next_interval(self) -&gt; float | None:\n\"\"\"Return the time to wait before the next retry.\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\nif self._limit is not None and self._count &gt;= self._limit:\nreturn None\nself._count += 1\nreturn self._interval + random.uniform(0.0, self._jitter)\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.LinearBackoff.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the retry counter.</p> <p>To be called as soon as a connection is successful.</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>def reset(self) -&gt; None:\n\"\"\"Reset the retry counter.\n    To be called as soon as a connection is successful.\n    \"\"\"\nself._count = 0\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.RetryStrategy","title":"frequenz.client.base.retry_strategy.RetryStrategy","text":"<p>             Bases: <code>ABC</code></p> <p>Interface for implementing retry strategies.</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>class RetryStrategy(ABC):\n\"\"\"Interface for implementing retry strategies.\"\"\"\n_limit: int | None\n_count: int\n@abstractmethod\ndef next_interval(self) -&gt; float | None:\n\"\"\"Return the time to wait before the next retry.\n        Returns `None` if the retry limit has been reached, and no more retries\n        are possible.\n        Returns:\n            Time until next retry when below retry limit, and None otherwise.\n        \"\"\"\ndef get_progress(self) -&gt; str:\n\"\"\"Return a string denoting the retry progress.\n        Returns:\n            String denoting retry progress in the form \"(count/limit)\"\n        \"\"\"\nif self._limit is None:\nreturn f\"({self._count}/\u221e)\"\nreturn f\"({self._count}/{self._limit})\"\ndef reset(self) -&gt; None:\n\"\"\"Reset the retry counter.\n        To be called as soon as a connection is successful.\n        \"\"\"\nself._count = 0\ndef copy(self) -&gt; RetryStrategy:\n\"\"\"Create a new instance of `self`.\n        Returns:\n            A deepcopy of `self`.\n        \"\"\"\nret = deepcopy(self)\nret.reset()\nreturn ret\ndef __iter__(self) -&gt; Iterator[float]:\n\"\"\"Return an iterator over the retry intervals.\n        Yields:\n            Next retry interval in seconds.\n        \"\"\"\nwhile True:\ninterval = self.next_interval()\nif interval is None:\nbreak\nyield interval\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.RetryStrategy-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.RetryStrategy.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[float]\n</code></pre> <p>Return an iterator over the retry intervals.</p> YIELDS DESCRIPTION <code>float</code> <p>Next retry interval in seconds.</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>def __iter__(self) -&gt; Iterator[float]:\n\"\"\"Return an iterator over the retry intervals.\n    Yields:\n        Next retry interval in seconds.\n    \"\"\"\nwhile True:\ninterval = self.next_interval()\nif interval is None:\nbreak\nyield interval\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.RetryStrategy.copy","title":"copy","text":"<pre><code>copy() -&gt; RetryStrategy\n</code></pre> <p>Create a new instance of <code>self</code>.</p> RETURNS DESCRIPTION <code>RetryStrategy</code> <p>A deepcopy of <code>self</code>.</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>def copy(self) -&gt; RetryStrategy:\n\"\"\"Create a new instance of `self`.\n    Returns:\n        A deepcopy of `self`.\n    \"\"\"\nret = deepcopy(self)\nret.reset()\nreturn ret\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.RetryStrategy.get_progress","title":"get_progress","text":"<pre><code>get_progress() -&gt; str\n</code></pre> <p>Return a string denoting the retry progress.</p> RETURNS DESCRIPTION <code>str</code> <p>String denoting retry progress in the form \"(count/limit)\"</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>def get_progress(self) -&gt; str:\n\"\"\"Return a string denoting the retry progress.\n    Returns:\n        String denoting retry progress in the form \"(count/limit)\"\n    \"\"\"\nif self._limit is None:\nreturn f\"({self._count}/\u221e)\"\nreturn f\"({self._count}/{self._limit})\"\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.RetryStrategy.next_interval","title":"next_interval  <code>abstractmethod</code>","text":"<pre><code>next_interval() -&gt; float | None\n</code></pre> <p>Return the time to wait before the next retry.</p> <p>Returns <code>None</code> if the retry limit has been reached, and no more retries are possible.</p> RETURNS DESCRIPTION <code>float | None</code> <p>Time until next retry when below retry limit, and None otherwise.</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>@abstractmethod\ndef next_interval(self) -&gt; float | None:\n\"\"\"Return the time to wait before the next retry.\n    Returns `None` if the retry limit has been reached, and no more retries\n    are possible.\n    Returns:\n        Time until next retry when below retry limit, and None otherwise.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/client/base/retry_strategy/#frequenz.client.base.retry_strategy.RetryStrategy.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the retry counter.</p> <p>To be called as soon as a connection is successful.</p> Source code in <code>frequenz/client/base/retry_strategy.py</code> <pre><code>def reset(self) -&gt; None:\n\"\"\"Reset the retry counter.\n    To be called as soon as a connection is successful.\n    \"\"\"\nself._count = 0\n</code></pre>"}]}